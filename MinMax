%.......................................
% utility
%.......................................
% determines the value of a given board position
%

utility(B,U) :-
    win(B,'x'),
    U = 1, 
    !
    .

utility(B,U) :-
    win(B,'o'),
    U = (-1), 
    !
    .

utility(B,U) :-
    U = 0
    .


%.......................................
% minimax
%.......................................
% The minimax algorithm always assumes an optimal opponent.
% For tic-tac-toe, optimal play will always result in a tie, so the algorithm is effectively playing not-to-lose.

% For the opening move against an optimal player, the best minimax can ever hope for is a tie.
% So, technically speaking, any opening move is acceptable.
% Save the user the trouble of waiting  for the computer to search the entire minimax tree 
% by simply selecting a random square.

% minimax(dmax,B,M,COL,U, ALPHA, BETA) :-
%     D2 is D + 1,
%     D2 == DMAX,
%     utilityestimate(B,U),      
%     !.

minimax(_,[E,E,E, E,E,E, E,E,E],M,COL,U, _, _) :-   
    blank_mark(E),
    COL = 4,
    !.

minimax(D,B,M,COL,U, ALPHA, BETA) :-
    D2 is D + 1,
    moves(B,L),          %%% get the list of available moves
    !,
    best(D2,B,M,L,COL,U, ALPHA, BETA),  %%% recursively determine the best available move
    !.

% if there are no more available moves, 
% then the minimax value is the utility of the given board position

minimax(_,B,_,_,U, _, _) :-
    utility(B,U)      
    .


%.......................................
% best
%.......................................
% determines the best move in a given list of moves by recursively calling minimax
%

% Pruning
alpha_beta_pruning(D,B,M,MOVES,U1, ALPHA, BETA, U2, COL2):-
    minimizing(M),    %%% If i'm minimizing, then previous player was maximizing with optionALPHA .
    U1 =< ALPHA,      %%% Thus if  (any other after =< COL =< ALPHA) then we know fully that this branch isn't getting picked
	  !.
alpha_beta_pruning(D,B,M,MOVES,U1, ALPHA, BETA, U2, COL2):-
	  NEWBETA is min(BETA,U1),
    best(D,B,M,MOVES,COL2,U2, ALPHA, NEWBETA)
    .

alpha_beta_pruning(D,B,M,MOVES,U1, ALPHA, BETA, U2, COL2):-
    maximizing(M),    %%% If i'm maximizing, then previous player was minimizing with option BETA.
    U1 >= BETA,       %%% Thus if (any other after >= COL >= BETA) then we know fully that this branch isn't getting picked
	  !.
alpha_beta_pruning(D,B,M,MOVES,U1, ALPHA, BETA, U2, COL2):-
	  NEWALPHA is max(ALPHA,U1),
    best(D,B,M,MOVES,COL2,U2, NEWALPHA, BETA)
    .


% if there is only one move left in the list...

best(D,B,M,[COL1],COL,U, ALPHA, BETA) :-
    move(B,COL1,M,B2),        %%% apply that move to the board,
    inverse_mark(M,M2), 
    !,  
    minimax(D,B2,M2,_COL,U, ALPHA, BETA),  %%% then recursively search for the utility value of that move.
    COL = COL1, !
    .

% if there is more than one move in the list...

best(D,B,M,[COL1|T],COL,U, ALPHA, BETA) :-
    move(B,COL1,M,B2),             %%% apply the first move (in the list) to the board,
    inverse_mark(M,M2), 
    !,
    minimax(D,B2,M2,_COL,U1, ALPHA, BETA),                         %%% recursively search for the utility value of that move,
    alpha_beta_pruning(D,B,M,T,U1, ALPHA, BETA, U2, COL2),         %%% stop searching if we already know it's not getting picked, else continue
    better(D,M,COL1,U1,COL2,U2,COL,U)                              %%% and choose the better of the two moves (based on their respective utility values).  
	  .

%.......................................
% better
%.......................................
% returns the better of two moves based on their respective utility values.
%
% if both moves have the same utility value, then one is chosen at random.

better(D,M,COL1,U1,COL2,U2,     COL,U) :-
    maximizing(M),                     %%% if the player is maximizing
    U1 > U2,                           %%% then greater is better.
    COL = COL1,
    U = U1,
    !
    .

better(D,M,COL1,U1,COL2,U2,     COL,U) :-
    minimizing(M),                     %%% if the player is minimizing,
    U1 < U2,                           %%% then lesser is better.
    COL = COL1,
    U = U1, 
    !
    .

better(D,M,COL1,U1,COL2,U2,     COL,U) :-
    U1 == U2,                          %%% if moves have equal utility,
    random_int_1n(10,R),               %%% then pick one of them at random
    better2(D,R,M,COL1,U1,COL2,U2,COL,U),    
    !
    .

better(D,M,COL1,U1,COL2,U2,     COL,U) :-        %%% otherwise, second move is better
    COL = COL2,
    U = U2,
    !
    .


%.......................................
% better2
%.......................................
% randomly selects two squares of the same utility value given a single probability
%

better2(D,R,M,COL1,U1,COL2,U2,  COL,U) :-
    R < 6,
    COL = COL1,
    U = U1, 
    !
    .

better2(D,R,M,COL1,U1,COL2,U2,  COL,U) :-
    COL = COL2,
    U = U2,
    !
    .
